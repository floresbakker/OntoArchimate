prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix dcm:       <http://purl.org/dc/dcmitype/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix owl:       <http://www.w3.org/2002/07/owl#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfa:      <http://www.w3.org/ns/rdfa#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix respec:    <https://respec.org/model/def/>
prefix sh:        <http://www.w3.org/ns/shacl#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix status:    <http://purl.org/adms/status/>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix vann:      <http://purl.org/vocab/vann/>
prefix void:      <http://rdfs.org/ns/void#>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xmlns:     <http://www.w3.org/2000/xmlns/model/def/> 
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix rule:      <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix section:   <https://data.rijksfinancien.nl/archisvg/id/section/>
prefix shp:       <https://data.rijksfinancien.nl/archisvg/model/shp/>
prefix standard:  <https://data.rijksfinancien.nl/archisvg/id/standard/>
prefix target:    <https://data.rijksfinancien.nl/archisvg/model/target/>

rule: {

archiSVG:
    a
      owl:Ontology,
      respec:Ontology,
      void:Dataset;
    dct:created '2024-02-14'^^xsd:date;
    dct:creator
      'Flores Bakker';
    respec:introduction '''
Introduction of archiSVG serialisation vocabulary.
'''@en;
   respec:objective '''Objective of archiSVG serialisation vocabulary'''@en;
    respec:audience '''Audience of archiSVG serialisation vocabulary'''@en;
    dct:description '''Description of archiSVG serialisation vocabulary'''@en;
    dct:abstract '''Abstract of archiSVG serialisation vocabulary'''@en; 
    skos:example """
@prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/> .
@prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/> .
@prefix model: <https://data.rijksfinancien.nl/archisvg/id/> .
@prefix prov: <http://www.w3.org/ns/prov#> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix xml1: <http://www.w3.org/XML/model/def/> .
@prefix xmlns: <http://www.w3.org/2000/xmlns/model/def/> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .
@prefix xsi: <http://www.w3.org/2001/XMLSchema-instance/model/def/> .

# Model

model:BasicModel-Document a archiSVG:Document ;
    rdf:_1 model:BasicModel-Model .

model:BasicModel-Model a archiSVG:Model ;
    rdf:_1 model:BasicModel-ModelName ;
    rdf:_2 model:BasicModel-Documentation ;
    rdf:_3 model:BasicModel-Elements ;
    rdf:_4 model:BasicModel-Relationships ;
    xmlns:xsi "http://www.w3.org/2001/XMLSchema-instance" ;
    xsi:schemaLocation "http://www.opengroup.org/xsd/archimate/3.0/ http://www.opengroup.org/xsd/archimate/3.1/archimate3_Model.xsd" ;
    xml1:xmlns "http://www.opengroup.org/xsd/archimate/3.0/" ;
    prov:wasDerivedFrom model:BasicModel ;
    archiSVG:identifier "Model-1" .

model:BasicModel-ModelName a archiSVG:Name ;
    rdf:_1 model:BasicModel-ModelNameText ;
    xml1:lang "en" .

model:BasicModel-ModelNameText a archiSVG:Text ;
    xml1:fragment "Basic Model" .
    
model:BasicModel-Documentation a archiSVG:Documentation ;
    rdf:_1 model:BasicModel-DocumentationText ;
    xml1:lang "en" .

model:BasicModel-DocumentationText a archiSVG:Text ;
    xml1:fragment "Example of a basic model with two elements and two relationships" .

# Elements

model:BasicModel-Elements a archiSVG:Elements ;
    rdf:_1 model:aBusinessActor-Element ;
    rdf:_2 model:aBusinessObject-Element ;
    rdf:_3 model:aBusinessRole-Element .

model:aBusinessActor-Element a archiSVG:Element ;
    rdf:_1 model:aBusinessActor-ElementName ;
    xsi:type "BusinessActor" ;
    prov:wasDerivedFrom model:aBusinessActor ;
    archiSVG:identifier "BusinessActor1" .

model:aBusinessActor-ElementName a archiSVG:Name ;
    rdf:_1 model:aBusinessActor-ElementNameText ;
    xml1:lang "en" .

model:aBusinessActor-ElementNameText a archiSVG:Text ;
    xml1:fragment "A business actor" .

model:aBusinessRole-Element a archiSVG:Element ;
    rdf:_1 model:aBusinessRole-ElementName ;
    xsi:type "BusinessRole" ;
    prov:wasDerivedFrom model:aBusinessRole ;
    archiSVG:identifier "BusinessRole1" .

model:aBusinessRole-ElementName a archiSVG:Name ;
    rdf:_1 model:aBusinessRole-ElementNameText ;
    xml1:lang "en" .

model:aBusinessRole-ElementNameText a archiSVG:Text ;
    xml1:fragment "A business role" .

# Relationships

model:BasicModel-Relationships a archiSVG:Relationships ;
    rdf:_1 model:aRelationship1-Relationship ;
    rdf:_2 model:aRelationship2-Relationship .

model:aRelationship1-Relationship a archiSVG:Relationship ;
    rdf:_1 model:aRelationship1-RelationshipName ;
    xsi:type "Assignment" ;
    prov:wasDerivedFrom model:aRelationship1 ;
    archiSVG:identifier "Relation_1" ;
    archiSVG:source "BusinessActor1" ;
    archiSVG:target "BusinessRole1" .

model:aRelationship1-RelationshipName a archiSVG:Name ;
    rdf:_1 model:aRelationship1-RelationshipNameText ;
    xml1:lang "en" .

model:aRelationship1-RelationshipNameText a archiSVG:Text ;
    xml1:fragment "Assignment Relationship"@en .

""";
    dct:language 'iso639-1:en';
    dct:license 'https://creativecommons.org/licenses/by/4.0/'^^xsd:anyURI;
    dct:publisher <https://www.example.com>;
    dct:status status:UnderDevelopment;
    dct:title 'archimate Core Vocabulary'@en;
    dct:source <https://www.example.com/archisvg-vocabulary>;
    foaf:homepage 'https://www.example.com/'^^xsd:anyURI;
    owl:versionInfo '1.0';
    vann:preferredNamespacePrefix 'archisvg';
    vann:preferredNamespaceUri 'https://data.rijksfinancien.nl/archisvg/model/def/';
    void:uriRegexPattern '^https://data.rijksfinancien.nl/archisvg/model/def/';
    void:uriSpace 'https://data.rijksfinancien.nl/xml/archisvg/def/'^^xsd:anyURI.


### Logic
 
shp:View
    a sh:NodeShape;
    sh:rule rule:View;
    sh:target target:View;
    skos:prefLabel 'view shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:View
    a sh:SPARQLTarget;
    rdfs:comment 'Select all views in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all views... 
  $this rdf:type archimate:View.
    
  # ...that are not processed yet
  filter not exists { 
    ?archiSVG_view rdf:type svg:Document ;
                   prov:wasDerivedFrom $this.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

rule:View
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an SVG image based on an archimate view.'@en;
    skos:prefLabel 'Archimate view to SVG rule'@en;
    sh:construct '''

prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:      <http://purl.org/dc/terms/>
prefix function: <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:     <http://www.w3.org/ns/prov#>
prefix rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix skos:     <http://www.w3.org/2004/02/skos/core#>
prefix svg:      <http://www.w3.org/SVG/model/def/>
prefix xml:      <http://www.w3.org/XML/model/def/>
prefix xmlns:    <http://www.w3.org/2000/xmlns/model/def/> 
prefix xsi:      <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

  ?doc   rdf:type svg:Document;
         skos:prefLabel ?svgLabel;
         skos:definition ?svgDefinition;
         rdf:_1 ?svg;
         prov:wasDerivedFrom $this.
         
  ?svg   rdf:type svg:Svg;
         xml:xmlns "http://www.w3.org/2000/svg" ;
         xmlns:xlink "http://www.w3.org/1999/xlink" ;
         svg:viewBox ?viewBox;
         svg:height "900";
         rdf:_1 ?style;
         rdf:_2 ?definitions;
         rdf:_3 ?elements;
         rdf:_4 ?relationships.

  ?style rdf:type svg:Style;
         xml:fragment """path, line, rect, circle, polyline, polygon {
      vector-effect: non-scaling-stroke;
    }""".
  
  ?definitions rdf:type svg:Defs;
         dct:subject "definitions";
         rdf:_1 ?definitionsRelations;
         rdf:_2 ?definitionsIcons.
         
  ?definitionsRelations rdf:type svg:G;  
         dct:subject "definitions of relations".
  
  ?definitionsIcons rdf:type svg:G;  
         dct:subject "definitions of icons".
  
  ?elements rdf:type svg:G;
         dct:subject "elements";
         skos:prefLabel "Archimate elements".
         
  ?relationships rdf:type svg:G;
         dct:subject "relationships";
         skos:prefLabel "Archimate relationships".

} where {

  # Get the archimate metadata of the archimate view
  optional{
  $this skos:prefLabel ?label;
        skos:definition ?definition.
  }
  
  bind(coalesce(?label, 'A view') as ?svgLabel)
  bind(coalesce(?definition, 'A view in an archimate model.') as ?svgDefinition)
  
  bind(function:getViewBox($this) as ?viewBox)
  
  # Create IRI's
  BIND(IRI(CONCAT(STR($this),"-SVG-Document"))              as ?doc)
  BIND(IRI(CONCAT(STR($this),"-SVG"))                       as ?svg)
  BIND(IRI(CONCAT(STR($this),"-SVG-Style"))                 as ?style)  
  BIND(IRI(CONCAT(STR($this),"-SVG-Definitions"))           as ?definitions)  
  BIND(IRI(CONCAT(STR($this),"-SVG-Definitions-Relations")) as ?definitionsRelations)  
  BIND(IRI(CONCAT(STR($this),"-SVG-Definitions-Icons"))     as ?definitionsIcons)  
  BIND(IRI(CONCAT(STR($this),"-SVG-Elements"))              as ?elements)
  BIND(IRI(CONCAT(STR($this),"-SVG-Relationships"))         as ?relationships)

  }
''';
    rdfs:isDefinedBy archiSVG:.

shp:DefinitionsIcons
    a sh:NodeShape;
    sh:rule rule:DefinitionsIcons;
    sh:target target:DefinitionsIcons;
    skos:prefLabel 'definitions icons shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:DefinitionsIcons
    a sh:SPARQLTarget;
    rdfs:comment 'Select all definitions of icons in the archisvg template.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct: <http://purl.org/dc/terms/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all definitions... 
  $this rdf:type svg:G;
      dct:subject "definitions of icons".
    
  # ...that are not processed yet
  filter not exists { 
  $this ?member ?definition.
  ?definition rdf:type svg:Symbol.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

rule:DefinitionsIcons
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates SVG definitions for icons.'@en;
    skos:prefLabel 'SVG definitions of icons rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xlink:     <https://www.w3.org/1999/xlink/model/def/>
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

  $this      ?member ?definition.
  
  ?definition rdf:type svg:Symbol;
              skos:prefLabel ?label;
              svg:id ?id;
              ?memberComponent ?component.

  ?component ?predicate ?object. 

} where {
 
  archiSVG:iconDefinitions
              ?member ?definitionTemplate.
  filter(strstarts(str(?member), concat(str(rdf:), '_')))  
  
  ?definitionTemplate 
              rdf:type svg:Symbol, archiSVG:Template;
              skos:prefLabel ?label;
              dct:related ?archimateClass;
              svg:id ?id;
              ?memberComponent ?componentTemplate.
  filter(strstarts(str(?memberComponent), concat(str(rdf:), '_')))
  
  # Only get the SVG templates for the archimate elements that are actually in use
  {select ?archimateClass where {
      
      ?archimateClass rdfs:subClassOf* archimate:Element.
      ?element 
          rdf:type ?archimateClass;
          rdfs:isDefinedBy ?model.
      ?viewNode foaf:depicts ?element.
      ?view 
           archimate:contains ?viewNode;
           rdfs:isDefinedBy ?model.       
      ?doc
           rdf:type svg:Document;
           prov:wasDerivedFrom ?view;
           rdf:_1 ?svg.
      ?svg rdf:_2 ?definitions.
      ?definitions rdf:_2 $this.
      }
  }
  
  ?componentTemplate 
             ?predicate ?object.

  bind(str(strafter(str(?member), concat(str(rdf:), '_')))          as ?definitionIdentifier)
  bind(str(strafter(str(?memberComponent), concat(str(rdf:), '_'))) as ?componentIdentifier) 
  
  # Create IRI's
  BIND(IRI(CONCAT(STR($this),"-Definition-", ?definitionIdentifier))     as ?definition)
  BIND(IRI(CONCAT(STR(?definition),"-Component-", ?componentIdentifier)) as ?component)  
  
  }
''';
    rdfs:isDefinedBy archiSVG:.    
    
shp:DefinitionsRelations
    a sh:NodeShape;
    sh:rule rule:DefinitionsRelations;
    sh:target target:DefinitionsRelations;
    skos:prefLabel 'definitions relations shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:DefinitionsRelations
    a sh:SPARQLTarget;
    rdfs:comment 'Select all definitions of relations in the archisvg template.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct: <http://purl.org/dc/terms/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all definitions... 
  $this rdf:type svg:G;
      dct:subject "definitions of relations".
    
  # ...that are not processed yet
  filter not exists { 
  $this ?member ?definition.
  ?definition rdf:type svg:Marker.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

rule:DefinitionsRelations
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates SVG definitions for relations.'@en;
    skos:prefLabel 'SVG definitions of relations rule'@en;
    sh:construct '''

prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:      <http://purl.org/dc/terms/>
prefix function: <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:     <http://www.w3.org/ns/prov#>
prefix rdf:      <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:     <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:     <http://www.w3.org/2004/02/skos/core#>
prefix svg:      <http://www.w3.org/SVG/model/def/>
prefix xml:      <http://www.w3.org/XML/model/def/>
prefix xsi:      <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

  $this      ?member ?definition.
  
  ?definition rdf:type svg:Marker;
              svg:id ?id;
              svg:markerWidth ?markerWidth;
              svg:markerHeight ?markerHeight;
              svg:refX ?refX;
              svg:refY ?refY;
              svg:orient ?orient;
              svg:markerUnits ?markerUnits;
              ?memberComponent ?component.

  ?component rdf:type ?svgClass;
             svg:fill ?fill ;
             svg:points ?points ;
             svg:stroke ?stroke ;
             svg:stroke-width ?strokeWidth ;
             svg:cx ?cx ;
             svg:cy ?cy ;
             svg:r ?r .   

} where {
 
  archiSVG:relationDefinitions
              ?member ?definitionTemplate.
  
  ?definitionTemplate 
              rdf:type svg:Marker, archiSVG:Definition;
              svg:id ?id;
              svg:markerWidth ?markerWidth;
              svg:markerHeight ?markerHeight;
              svg:refX ?refX;
              svg:refY ?refY;
              svg:orient ?orient;
              svg:markerUnits ?markerUnits;
              ?memberComponent ?componentTemplate.

  ?componentTemplate 
             rdf:type ?svgClass, archiSVG:Definition;
             svg:fill ?fill ;
             svg:stroke ?stroke ;
             svg:stroke-width ?strokeWidth .

  ?svgClass rdfs:subClassOf svg:Element.     
 
  optional {?componentTemplate svg:points ?points.}
  optional {?componentTemplate 
              svg:cx ?cx ;
              svg:cy ?cy ;
              svg:r ?r .  }

  bind(str(strafter(str(?member), concat(str(rdf:), '_')))          as ?definitionIdentifier)
  bind(str(strafter(str(?memberComponent), concat(str(rdf:), '_'))) as ?componentIdentifier) 
  
  # Create IRI's
  BIND(IRI(CONCAT(STR($this),"-Definition-", ?definitionIdentifier))     as ?definition)
  BIND(IRI(CONCAT(STR(?definition),"-Component-", ?componentIdentifier)) as ?component)  
  
  }
''';
    rdfs:isDefinedBy archiSVG:.    

shp:NodeCreator
    a sh:NodeShape;
    sh:rule rule:NodeCreator, rule:NodeBoxCreator, rule:NodeIconCreator, rule:NodeTextCreator;
    sh:target target:NodeCreator;
    skos:prefLabel 'node creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:NodeCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archimate view nodes in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all archimate view nodes... 
  
  $this rdf:type archimate:ViewNode.
 
  # ...that are not processed yet
  filter not exists { 
    ?archiSVG_node 
       rdf:type svg:G ;
       prov:wasDerivedFrom $this.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.


rule:NodeCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archisvg node in the XML document based on an archimate view node.'@en;
    skos:prefLabel 'archisvg node creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xlink:     <https://www.w3.org/1999/xlink/model/def/> 
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

    ?elementNode 
          rdf:type svg:G, archiSVG:Element;
          skos:prefLabel ?elementName;
          svg:transform  ?translate;
          rdf:_1 ?box;
          rdf:_2 ?icon;
          rdf:_3 ?text;
          prov:wasDerivedFrom $this;
          foaf:depicts ?element.

} where {
  
  $this
    archimate:horizontal ?horizontal;
    archimate:vertical   ?vertical.
  
  # Calculate the translation of the box position against the position of the template box
  bind(concat('translate(', str(?horizontal), ',', str(?vertical), ')') as ?translate)
    
  # A view node depicts an element, get the metadata for this.
  $this foaf:depicts ?element.
  ?element rdf:type ?archimateClass;
           skos:prefLabel ?elementName.
  ?archimateClass rdfs:subClassOf* archimate:Element.

  # Create IRI's
  bind(iri(concat(str($this),"-SVG-Element"))                                    as ?elementNode)
  bind(iri(concat(str($this),"-SVG-Element","-Box"))                             as ?box)
  bind(iri(concat(str($this),"-SVG-Element","-Icon"))                            as ?icon)
  bind(iri(concat(str($this),"-SVG-Element","-Text"))                            as ?text)
}

''';
    rdfs:isDefinedBy archiSVG:.

shp:NodeBoxCreator
    a sh:NodeShape;
    sh:rule rule:NodeBoxCreator;
    sh:target target:NodeBoxCreator;
    skos:prefLabel 'node box creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:NodeBoxCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archimate view nodes in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all archimate view nodes whose box is not processed yet... 
  
  $this rdf:type archimate:ViewNode.
  ?archiSVG_node 
    rdf:type svg:G ;
    rdf:_1 ?box;
    prov:wasDerivedFrom $this.
  filter not exists {
  ?box ?anyPredicate ?anyObject
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

    
rule:NodeBoxCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archisvg box node in the XML document based on an archimate view node.'@en;
    skos:prefLabel 'archisvg box node creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xlink:     <https://www.w3.org/1999/xlink/model/def/> 
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

    ?box 
          rdf:type svg:Path;
          skos:prefLabel ?elementName;
          svg:d         ?path ;
          svg:transform ?scale;
          svg:fill      ?fillColor ;
          svg:stroke    ?lineColor .

} where {
  
  $this foaf:depicts ?element.
  ?element rdf:type ?archimateClass;
           skos:prefLabel ?elementName.
  ?archimateClass rdfs:subClassOf* archimate:Element.
  
  ?svgTemplate rdf:type svg:G, archiSVG:Template;
               foaf:depicts ?archimateClass;
               rdf:_1 ?boxTemplate.

  ?boxTemplate rdf:type svg:Path, archiSVG:Template;
               svg:d      ?path ;
               svg:fill   ?defaultFillColor ;
               svg:stroke ?defaultLineColor .
               
  optional {
  $this
    archimate:height     ?heightElement; 
    archimate:width      ?widthElement.
  }
  
  optional {
  $this
    archimate:fillColor  ?fillColorIRI;
    archimate:lineColor  ?lineColorIRI.
    
  ?fillColorIRI rdf:type archimate:Color;
    archimate:red   ?fillColorR;
    archimate:green ?fillColorG;
    archimate:blue  ?fillColorB. 

  bind(concat("rgb(", ?fillColorR, "," ,?fillColorG, "," ,?fillColorB, ")") as ?fillColorElement)

  ?lineColorIRI rdf:type archimate:Color;
    archimate:red   ?lineColorR;
    archimate:green ?lineColorG;
    archimate:blue  ?lineColorB.
  
  bind(concat("rgb(", ?lineColorR, "," ,?lineColorG, "," ,?lineColorB, ")") as ?lineColorElement)
  }               
  
  bind(coalesce(?heightElement,    "55")                       as ?height)
  bind(coalesce(?widthElement,     "144")                      as ?width)
  bind(coalesce(?fillColorElement, ?defaultFillColor)          as ?fillColor)
  bind(coalesce(?lineColorElement, ?defaultLineColor)          as ?lineColor)  
    
  # Calculate the scaling of the box against the size of the template box
  bind(concat('scale(', str(xsd:integer(?width)/144), ',', str(xsd:integer(?height)/55), ')') as ?scale)
  
  # Create IRI's
  bind(iri(concat(str($this),"-SVG-Element","-Box")) as ?box)

}

''';
    rdfs:isDefinedBy archiSVG:.    
    
shp:NodeIconCreator
    a sh:NodeShape;
    sh:rule rule:NodeIconCreator;
    sh:target target:NodeIconCreator;
    skos:prefLabel 'node icon creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:NodeIconCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archimate view nodes in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all archimate view nodes whose icon is not processed yet... 
  
  $this rdf:type archimate:ViewNode.
  ?archiSVG_node 
    rdf:type svg:G ;
    rdf:_2 ?icon;
    prov:wasDerivedFrom $this.
  filter not exists {
  ?icon ?anyPredicate ?anyObject
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

    
rule:NodeIconCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archisvg  icon node in the XML document based on an archimate view node.'@en;
    skos:prefLabel 'archisvg icon node creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xlink:     <https://www.w3.org/1999/xlink/model/def/> 
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {
          
    ?icon 
          skos:prefLabel ?elementName;
          rdf:type svg:Use;
          svg:transform ?iconTranslate;
          xlink:href ?iconID.

} where {
  
  $this foaf:depicts ?element.
  ?element rdf:type ?archimateClass;
           skos:prefLabel ?elementName.
  ?archimateClass rdfs:subClassOf* archimate:Element.
  
  ?svgTemplate rdf:type svg:G, archiSVG:Template;
               foaf:depicts ?archimateClass;
               rdf:_2 ?iconTemplate.

  ?iconTemplate rdf:type svg:Use, archiSVG:Template;
                xlink:href ?iconID.
               
  optional {
  $this
    archimate:width      ?widthElement.
  }
            
  bind(coalesce(?widthElement,     "144")                      as ?width)
 
  # Calculate the translation of the icon position compensating for the size of the box against the size of the template box
  bind(concat('translate(', str(xsd:integer(?width)-144), ', 0)') as ?iconTranslate)
  
  # Create IRI's
  bind(iri(concat(STR($this),"-SVG-Element","-Icon")) as ?icon)

}

''';
    rdfs:isDefinedBy archiSVG:.

shp:NodeTextCreator
    a sh:NodeShape;
    sh:rule rule:NodeTextCreator;
    sh:target target:NodeTextCreator;
    skos:prefLabel 'node text creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:NodeTextCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archimate view nodes in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg: <http://www.w3.org/SVG/model/def/>

select $this {

  # Select all archimate view nodes whose text is not processed yet... 
  
  $this rdf:type archimate:ViewNode.
  ?archiSVG_node 
    rdf:type svg:G ;
    rdf:_3 ?text;
    prov:wasDerivedFrom $this.
  filter not exists {
  ?text ?anyPredicate ?anyObject
  }
}
''';
    rdfs:isDefinedBy archiSVG:.



rule:NodeTextCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archisvg text node in the XML document based on an archimate view node.'@en;
    skos:prefLabel 'archisvg text node creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xlink:     <https://www.w3.org/1999/xlink/model/def/> 
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {
          
    ?text 
          rdf:type svg:TextElement, archiSVG:TextElement ;
          skos:prefLabel     ?elementName;
          svg:font-family    ?fontName ;
          svg:font-size      ?fontSize ;
          svg:x              ?textX ;
          svg:y              ?textY ;
          svg:text-anchor    ?textAnchor;
          archiSVG:maxChars  ?maxChars;
          archiSVG:maxLines  ?maxLines;
          archiSVG:textLines ?textLines.

} where {
  
  $this foaf:depicts ?element.
  ?element rdf:type ?archimateClass;
           skos:prefLabel ?elementName.
  ?archimateClass rdfs:subClassOf* archimate:Element.
  
  ?svgTemplate rdf:type svg:G, archiSVG:Template;
               foaf:depicts ?archimateClass;
               rdf:_3 ?textTemplate.

  ?textTemplate rdf:type svg:TextElement, archiSVG:Template;
                svg:font-family ?defaultFontName ;
                svg:font-size   ?defaultFontSize ;
                svg:y           ?textY.
  optional {
  ?textTemplate svg:text-anchor ?templateTextAnchor.
  }
  
  bind(coalesce(?templateTextAnchor, "middle") as ?textAnchor)

  optional {
  $this
    archimate:height     ?heightElement; 
    archimate:width      ?widthElement.
  }
  
  bind(coalesce(?heightElement,    "55")                       as ?height)
  bind(coalesce(?widthElement,     "144")                      as ?width)
  
  optional {  
    $this archimate:font ?fontIRI.
    ?fontIRI 
             rdf:type archimate:Font;
             archimate:fontName  ?fontNameElement;
             archimate:fontSize  ?fontSizeElement;
  }
 
  bind(coalesce(?fontNameElement,  ?defaultFontName)           as ?fontName)
  bind(coalesce(?fontSizeElement,  ?defaultFontSize)           as ?fontSize)
  
  # Establish text area limits
  
  # Calculate available space for text (98% of box width)
  bind(xsd:integer(floor(xsd:integer(?width) * 0.98)) as ?textWidth)  

  # Approximate max chars per line based on font size (each character on average takes up 0.6 of fontsize in width)
  bind(xsd:integer(floor(?textWidth / (xsd:integer(?fontSize) * 0.6))) as ?maxChars)

  # Calculate how many lines fit in the box (120% of fontsize per line)
  bind(xsd:integer(floor(xsd:integer(?height) / (xsd:integer(?fontSize) * 1.2))) as ?maxLines)

  # Calculate how many lines are needed
  bind(xsd:integer(ceil(strlen(?elementName)/?maxChars)) as ?textLines)
  
  # Calculate the text position
  bind(if(?textAnchor="middle", xsd:integer(?width)/2, if(?textAnchor="start", 10, xsd:integer(?width)-10)) as ?textX)
  
  # Create IRI's
  bind(iri(concat(str($this),"-SVG-Element","-Text"))                            as ?text)
  bind(iri(concat(str($this),"-SVG-Element","-TextFragment"))                    as ?textFragment)

}

''';
    rdfs:isDefinedBy archiSVG:.    

shp:ContainerCreator
    a sh:NodeShape;
    #sh:rule rule:ContainerCreator;
    sh:target target:ContainerCreator;
    skos:prefLabel 'container creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ContainerCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archimate containers in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

select $this {

  # Select all archimate containers... 

  $this rdf:type archimate:Container.
  
  # ...that are not processed yet
  filter not exists { 
    ?archiSVG_node rdf:type archiSVG:Node ;
                   prov:wasDerivedFrom $this.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.


rule:ContainerCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archixml node in the XML document based on an archimate container.'@en;
    skos:prefLabel 'archixml container creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct: <http://purl.org/dc/terms/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix function: <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix xml: <http://www.w3.org/XML/model/def/>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>
prefix xsi: <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

   ?elementNode rdf:type archiSVG:Node;
           xsi:type ?xsiType;
           archiSVG:x ?x ;
           archiSVG:y ?y ;
           archiSVG:w ?w ;
           archiSVG:h ?h ;
           prov:wasDerivedFrom $this;
           rdf:_1 ?labelNode;
           rdf:_2 ?nodeStyleIRI.
   ?labelNode rdf:type archiSVG:Label;
           rdf:_1 ?labelTextNode.
   ?labelTextNode rdf:type archiSVG:Text;
           xml:fragment ?label.
   ?nodeStyleIRI rdf:type archiSVG:Style;
           rdf:_1 ?fillColorIRI;
           rdf:_2 ?lineColorIRI;
           rdf:_3 ?fontIRI.
   ?fillColorIRI rdf:type archiSVG:FillColor;
           archiSVG:a ?fillColorA ;
           archiSVG:b ?fillColorB ;
           archiSVG:g ?fillColorG ;
           archiSVG:r ?fillColorR .
   ?lineColorIRI rdf:type archiSVG:LineColor;
           archiSVG:a ?lineColorA ;
           archiSVG:b ?lineColorB ;
           archiSVG:g ?lineColorG ;
           archiSVG:r ?lineColorR .
   ?fontIRI rdf:type archiSVG:Font;
           archiSVG:name ?fontName;
           archiSVG:size ?fontSize;
           rdf:_1 ?fontColorIRI.
   ?fontColorIRI rdf:type archiSVG:Color;
           archiSVG:b ?fontColorB ;
           archiSVG:g ?fontColorG ;
           archiSVG:r ?fontColorR .

} where {

  # Get the archimate metadata of the archimate view
  ?archimateView rdf:type archimate:View;
                  archimate:contains* $this.

  # Establish the unique sequence number of a container across the model
  {select $this ((count(?prevIndex)+1) as ?indexContainer)
   where {
    $this rdf:type archimate:Container.
    bind(str($this) as ?index)
    optional {
              ?prevContainer rdf:type archimate:Container.
              bind(str(?prevContainer) as ?prevIndex)
              filter(?prevIndex < ?index)
             } 
     } group by $this
  }
  bind(concat("Container", str(?indexContainer)) as ?containerIdentifier)
  bind("Container" as ?xsiType)

  # Get optional label for container
  optional {
  $this  
      skos:prefLabel ?label.
  }
  
  optional {
  $this
    archimate:horizontal ?x;
    archimate:vertical   ?y;
    archimate:height     ?h;
    archimate:width      ?w.
  }

  optional {
  $this
    archimate:fillColor  ?fillColor;
    archimate:lineColor  ?lineColor;
    archimate:font       ?font.

  ?fillColor rdf:type archimate:Color;
    archimate:red   ?fillColorR;
    archimate:green ?fillColorG;
    archimate:blue  ?fillColorB;
    archimate:alpha ?fillColorA. 

  ?lineColor rdf:type archimate:Color;
    archimate:red   ?lineColorR;
    archimate:green ?lineColorG;
    archimate:blue  ?lineColorB;
    archimate:alpha ?lineColorA. 

  ?font rdf:type archimate:Font;
    archimate:fontName  ?fontName;
    archimate:fontSize  ?fontSize;
    archimate:fontColor ?fontColor.

  ?fontColor rdf:type archimate:Color;
    archimate:red   ?fontColorR;
    archimate:green ?fontColorG;
    archimate:blue  ?fontColorB.
  }
  # Set unique identifier
  BIND(CONCAT("Node_",STR(?containerIdentifier)) as ?nodeIdentifier)

  # Create IRI's
  BIND(IRI(CONCAT(STR(?archimateView),"-View-"))                           as ?view)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier))                             as ?elementNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-label"))                   as ?labelNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-labelText"))               as ?labelTextNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-nodestyle"))               as ?nodeStyleIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-fillcolor"))               as ?fillColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-linecolor"))               as ?lineColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-font"))                    as ?fontIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-fontcolor"))               as ?fontColorIRI)

  }
''';
    rdfs:isDefinedBy archiSVG:.

shp:LabelCreator
    a sh:NodeShape;
    #sh:rule rule:LabelCreator;
    sh:target target:LabelCreator;
    skos:prefLabel 'label creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:LabelCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archimate notes in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

select $this {

  # Select all potential archimate notes... 
  
  $this rdf:type archimate:Note.
  
  # ...that are not processed yet
  filter not exists { 
    ?archiSVG_node rdf:type archiSVG:Node ;
                   prov:wasDerivedFrom $this.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.


rule:LabelCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archixml node in the XML document based on an archimate note.'@en;
    skos:prefLabel 'archixml label creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct: <http://purl.org/dc/terms/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix function: <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix xml: <http://www.w3.org/XML/model/def/>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>
prefix xsi: <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {
             
   ?elementNode rdf:type archiSVG:Node;
           xsi:type ?xsiType;
           archiSVG:x ?x ;
           archiSVG:y ?y ;
           archiSVG:w ?w ;
           archiSVG:h ?h ;
           prov:wasDerivedFrom $this;
           rdf:_1 ?labelNode;
           rdf:_2 ?nodeStyleIRI.
   ?labelNode rdf:type archiSVG:Label;
           rdf:_1 ?labelTextNode.
   ?labelTextNode rdf:type archiSVG:Text;
           xml:fragment ?label.
   ?nodeStyleIRI rdf:type archiSVG:Style;
           rdf:_1 ?fillColorIRI;
           rdf:_2 ?lineColorIRI;
           rdf:_3 ?fontIRI.
   ?fillColorIRI rdf:type archiSVG:FillColor;
           archiSVG:a ?fillColorA ;
           archiSVG:b ?fillColorB ;
           archiSVG:g ?fillColorG ;
           archiSVG:r ?fillColorR .
   ?lineColorIRI rdf:type archiSVG:LineColor;
           archiSVG:a ?lineColorA ;
           archiSVG:b ?lineColorB ;
           archiSVG:g ?lineColorG ;
           archiSVG:r ?lineColorR .
   ?fontIRI rdf:type archiSVG:Font;
           archiSVG:name ?fontName;
           archiSVG:size ?fontSize;
           rdf:_1 ?fontColorIRI.
   ?fontColorIRI rdf:type archiSVG:Color;
           archiSVG:b ?fontColorB ;
           archiSVG:g ?fontColorG ;
           archiSVG:r ?fontColorR .

} where {

  # Get the archimate metadata of the archimate view
  ?archimateView rdf:type archimate:View;
                  archimate:contains* $this.

  # A view node can be a note, get the metadata for this
  # Establish the unique sequence number of a note across the model
  {select $this ((count(?prevIndex)+1) as ?indexNote)
   where {
    $this rdf:type archimate:Note.
    bind(str($this) as ?index)
    optional {
              ?prevNote rdf:type archimate:Note.
              bind(str(?prevNote) as ?prevIndex)
              filter(?prevIndex < ?index)
             } 
     } group by $this
  }
  bind(concat("Label", str(?indexNote)) as ?labelIdentifier)
  bind("Label" as ?xsiType)
  
  # Get optional label for the note
  optional {
  $this  
      skos:prefLabel ?label.
  }
  
  optional {
  $this
    archimate:horizontal ?x;
    archimate:vertical   ?y;
    archimate:height     ?h;
    archimate:width      ?w.
  }
  
  optional {
  $this
    archimate:fillColor  ?fillColor;
    archimate:lineColor  ?lineColor;
    archimate:font       ?font.
    
  ?fillColor rdf:type archimate:Color;
    archimate:red   ?fillColorR;
    archimate:green ?fillColorG;
    archimate:blue  ?fillColorB;
    archimate:alpha ?fillColorA. 

  ?lineColor rdf:type archimate:Color;
    archimate:red   ?lineColorR;
    archimate:green ?lineColorG;
    archimate:blue  ?lineColorB;
    archimate:alpha ?lineColorA. 

  ?font rdf:type archimate:Font;
    archimate:fontName  ?fontName;
    archimate:fontSize  ?fontSize;
    archimate:fontColor ?fontColor.

  ?fontColor rdf:type archimate:Color;
    archimate:red   ?fontColorR;
    archimate:green ?fontColorG;
    archimate:blue  ?fontColorB.
  }
  # Set unique identifier
  BIND(CONCAT("Node_",STR(?labelIdentifier)) as ?nodeIdentifier)

  # Create IRI's
  BIND(IRI(CONCAT(STR(?archimateView),"-View-"))                           as ?view)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier))                             as ?elementNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-label"))                   as ?labelNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-labelText"))               as ?labelTextNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-nodestyle"))               as ?nodeStyleIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-fillcolor"))               as ?fillColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-linecolor"))               as ?lineColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-font"))                    as ?fontIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-fontcolor"))               as ?fontColorIRI)
 
  }
''';
    rdfs:isDefinedBy archiSVG:.    

shp:ViewReferenceCreator
    a sh:NodeShape;
    #sh:rule rule:ViewReferenceCreator;
    sh:target target:ViewReferenceCreator;
    skos:prefLabel 'view reference creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ViewReferenceCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all view references in the archimate model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

select $this {

  # Select all nested view references... 
  
  $this rdf:type archimate:ViewReference.
  
  # ...that are not processed yet
  filter not exists { 
    ?archiSVG_node rdf:type archiSVG:Node ;
                   prov:wasDerivedFrom $this.
  }
}
''';
    rdfs:isDefinedBy archiSVG:.


rule:ViewReferenceCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archixml node in the XML document based on a view reference.'@en;
    skos:prefLabel 'archixml view reference creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

   ?elementNode rdf:type archiSVG:Node;
           xsi:type ?xsiType;
           archiSVG:x ?x ;
           archiSVG:y ?y ;
           archiSVG:w ?w ;
           archiSVG:h ?h ;
           prov:wasDerivedFrom $this;
           rdf:_1 ?labelNode;
           rdf:_2 ?nodeStyleIRI;
           rdf:_3 ?viewRefIRI.
   ?labelNode rdf:type archiSVG:Label;
           rdf:_1 ?labelTextNode.
   ?labelTextNode rdf:type archiSVG:Text;
           xml:fragment ?label.
   ?nodeStyleIRI rdf:type archiSVG:Style;
           rdf:_1 ?fillColorIRI;
           rdf:_2 ?lineColorIRI;
           rdf:_3 ?fontIRI.
   ?fillColorIRI rdf:type archiSVG:FillColor;
           archiSVG:a ?fillColorA ;
           archiSVG:b ?fillColorB ;
           archiSVG:g ?fillColorG ;
           archiSVG:r ?fillColorR .
   ?lineColorIRI rdf:type archiSVG:LineColor;
           archiSVG:a ?lineColorA ;
           archiSVG:b ?lineColorB ;
           archiSVG:g ?lineColorG ;
           archiSVG:r ?lineColorR .
   ?fontIRI rdf:type archiSVG:Font;
           archiSVG:name ?fontName;
           archiSVG:size ?fontSize;
           rdf:_1 ?fontColorIRI.
   ?fontColorIRI rdf:type archiSVG:Color;
           archiSVG:b ?fontColorB ;
           archiSVG:g ?fontColorG ;
           archiSVG:r ?fontColorR . 
   ?viewRefIRI rdf:type archiSVG:ViewRef;
           archiSVG:ref ?viewIdentifier.

} where {

  # Get the archimate metadata of the archimate view
  ?archimateView rdf:type archimate:View;
                  archimate:contains* $this.
  $this foaf:depicts ?referencedView.
  ?archiSVGview prov:wasDerivedFrom ?referencedView;
                rdf:type archiSVG:View;
                archiSVG:identifier ?viewIdentifier.

  # Get the view reference metadata
  # Establish the unique sequence number of the view reference across the model
  {select $this ((count(?prevIndex)+1) as ?indexRef)
   where {
    $this rdf:type archimate:ViewReference.
    bind(str($this) as ?index)
    optional {
              ?prevReference rdf:type archimate:ViewReference.
              bind(str(?prevReference) as ?prevIndex)
              filter(?prevIndex < ?index)
             } 
     } group by $this
  }
  bind(concat("ViewReference", str(?indexRef)) as ?labelIdentifier)
  bind("Label" as ?xsiType)

  # Get optional label for the note
  optional {
  $this  
      skos:prefLabel ?label.
  }

  optional {
  $this
    archimate:horizontal ?x;
    archimate:vertical   ?y;
    archimate:height     ?h;     
    archimate:width      ?w.
  }

  optional {
  $this
    archimate:fillColor  ?fillColor;
    archimate:lineColor  ?lineColor;
    archimate:font       ?font.
    
  ?fillColor rdf:type archimate:Color;
    archimate:red   ?fillColorR;
    archimate:green ?fillColorG;
    archimate:blue  ?fillColorB;
    archimate:alpha ?fillColorA. 

  ?lineColor rdf:type archimate:Color;
    archimate:red   ?lineColorR;
    archimate:green ?lineColorG;
    archimate:blue  ?lineColorB;
    archimate:alpha ?lineColorA. 

  ?font rdf:type archimate:Font;
    archimate:fontName  ?fontName;
    archimate:fontSize  ?fontSize;
    archimate:fontColor ?fontColor.

  ?fontColor rdf:type archimate:Color;
    archimate:red   ?fontColorR;
    archimate:green ?fontColorG;
    archimate:blue  ?fontColorB.
  }
  # Set unique identifier
  BIND(CONCAT("Node_",STR(?labelIdentifier)) as ?nodeIdentifier)

  # Create IRI's
  BIND(IRI(CONCAT(STR(?archimateView),"-View-"))                           as ?view)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier))                             as ?elementNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-label"))                   as ?labelNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-labelText"))               as ?labelTextNode)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-nodestyle"))               as ?nodeStyleIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-fillcolor"))               as ?fillColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-linecolor"))               as ?lineColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-font"))                    as ?fontIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-fontcolor"))               as ?fontColorIRI)
  BIND(IRI(CONCAT(STR(?view),?nodeIdentifier, "-viewref"))                 as ?viewRefIRI)
 
  }
''';
    rdfs:isDefinedBy archiSVG:.    

shp:ConnectionCreator
    a sh:NodeShape;
    sh:rule rule:ConnectionCreator;
    sh:target target:ConnectionCreator;
    skos:prefLabel 'connection creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ConnectionCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all view connections in the model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

select $this {

  # Select all view connections... 
  $this rdf:type archimate:Connection.
    
  # ...that are not processed yet
  filter not exists { 
    ?archiSVG_view rdf:type archiSVG:Connection ;
                   prov:wasDerivedFrom $this.
  }

  # ...but only if all the archimate view nodes in the view are already processed
  filter not exists {
  ?archimateView archimate:contains $this;
                 archimate:contains ?viewnodes.
  ?viewnodes rdf:type archimate:ViewNode.
   filter not exists {
       [] prov:wasDerivedFrom ?viewnodes.
    }
  }
  
  # ...and only if all the archimate connections in the view are already processed
  filter not exists {
  $this  
     foaf:depicts ?relationship.
  ?relationship 
     archimate:to | archimate:from ?otherRelationship.
  ?otherRelationship 
     rdf:type archimate:Relationship.
  ?otherConnection 
     rdf:type archimate:Connection;
     foaf:depicts ?otherRelationship.
   filter not exists {
       [] prov:wasDerivedFrom ?otherConnection.
    }
  }
}
''';
    rdfs:isDefinedBy archiSVG:.


rule:ConnectionCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates a connection in the XML document based on a relationship in an archimate view.'@en;
    skos:prefLabel 'archimate connection creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>

construct {

    ?connection
          rdf:type svg:G, archiSVG:Connection;
          skos:prefLabel ?relationshipName;
          rdf:_1 ?connectionPart;
          archiSVG:accessType ?accessType;
          archiSVG:fromX ?fromX ;
          archiSVG:fromY ?fromY ;
          archiSVG:fromW ?fromW ;
          archiSVG:fromH ?fromH ;
          archiSVG:toX ?toX ;
          archiSVG:toY ?toY ;
          archiSVG:toW ?toW ;
          archiSVG:toH ?toH ;
          prov:wasDerivedFrom $this;
          foaf:depicts ?relationship;
          archiSVG:bendPoint ?bendPointListSVG.
          
    ?bendPointListSVG ?memberBendPoint ?bendPointSVG.
  
    ?bendPointSVG
         rdf:type archiSVG:BendPoint;
         archiSVG:toX   ?x;
         archiSVG:toY   ?y;
         archiSVG:fromX ?x;
         archiSVG:fromY ?y.          
         
    ?connectionPart
          rdf:type svg:Polyline, archiSVG:ConnectionLine;
          prov:wasDerivedFrom ?iconTemplate.

}
  where {

  ?archimateView archimate:contains $this.
  $this foaf:depicts ?relationship.
  ?relationship rdf:type archimate:Relationship;
                archimate:from ?fromArchimateElement;
                archimate:relationship ?relationType;
                archimate:to ?toArchimateElement;
                skos:prefLabel ?relationshipName.
  ?relationType rdf:type/rdfs:subClassOf+ archimate:RelationType.

  optional {
  ?relationship archimate:accessType ?accessType.}

  ?archimateView archimate:contains+ ?source, ?target.
  ?source foaf:depicts ?fromArchimateElement.
  ?target foaf:depicts ?toArchimateElement.

  optional {
  ?source
    archimate:horizontal ?fromX;
    archimate:vertical   ?fromY.
  }
  
  optional {
  ?svgSourceConnection 
     rdf:type archiSVG:Connection;
     prov:wasDerivedFrom ?source;
     archiSVG:middleX ?fromX;
     archiSVG:middleY ?fromY;
  }

  optional {
  ?source
    archimate:height     ?fromH;
    archimate:width      ?fromW.
  }

  optional {
  ?target
    archimate:horizontal ?toX;
    archimate:vertical   ?toY.
  }

  optional {
  ?svgTargetConnection 
     rdf:type archiSVG:Connection;
     prov:wasDerivedFrom ?target;
     archiSVG:middleX ?toX;
     archiSVG:middleY ?toY;
  }

  optional {
  ?target
    archimate:height     ?toH;
    archimate:width      ?toW.

  }
  
optional {
  $this 
     archimate:bendPoint ?bendPointList.
  ?bendPointList rdf:rest*/rdf:first ?bendPoint.
  
  ?bendPoint 
     rdf:type archimate:BendPoint;
     archimate:horizontal ?x;
     archimate:vertical   ?y.
  }  

  # Establish the bendpoint index, if present
  optional {
  {select ?bendPointList ?bendPoint (count(?sublist) as ?indexBendPoint) {
   $this rdf:type archimate:Connection;
         archimate:bendPoint ?bendPointList.
   ?bendPointList rdf:rest* ?sublist.
   ?sublist rdf:rest*/rdf:first ?bendPoint.
    } group by ?bendPointList ?bendPoint
   }
  BIND(IRI(CONCAT(STR(rdf:), "_", STR(?indexBendPoint))) as ?memberBendPoint)
  }
  
  # Get the template SVG for the relationship.
  ?svgTemplate rdf:type svg:G, archiSVG:Template;
               foaf:depicts ?relationType;
               rdf:_1 ?iconTemplate.

  # Create IRI's
  BIND(IRI(CONCAT(STR($this),"-SVG-Relationship"))                                                         as ?connection)
  BIND(IRI(CONCAT(STR($this),"-SVG-Relationship","-1"))                                                    as ?connectionPart)
  BIND(IF(BOUND(?bendPointList),IRI(CONCAT(STR($this),"-SVG-Relationship","-bendPoints")), ?unboundDummy)  as ?bendPointListSVG)
  BIND(IRI(CONCAT(STR($this),"-SVG-Relationship","-bendPoint-", str(?indexBendPoint)))                     as ?bendPointSVG)

}
''';
    rdfs:isDefinedBy archiSVG:.

shp:NodeConnector
    a sh:NodeShape;
    sh:rule rule:NodeConnector;
    sh:target target:NodeConnector;
    skos:prefLabel 'node connector shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:NodeConnector
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archixml nodes in the model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

select $this {

  # Select all archisvg elements for which a parent exists but who are not connected yet.
  $this rdf:type archiSVG:Element;

  # ...that are not processed yet
  filter not exists { 
    ?parentNode ?member $this.
    filter(strstarts(str(?member), concat(str(rdf:), '_')))
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

rule:NodeConnector
    a sh:SPARQLRule;
    rdfs:comment 'A rule that connects a node in the XML document with its parent node or archimate view.'@en;
    skos:prefLabel 'archimate node connector rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

  ?elements ?memberNode $this.

} where {

  # Get the elements node
  $this prov:wasDerivedFrom ?node. 
  ?view   archimate:contains* ?node.
  ?documentNode rdf:type svg:Document;
                prov:wasDerivedFrom ?view;
                rdf:_1 ?svg.
  ?svg rdf:_3 ?elements.

  # Establish position of the element within the view
  {select ?view ?node ((count(?prevIndex)) as ?indexMember)
   where{
    ?view rdf:type archimate:View;
          archimate:contains* ?node.
    bind(str(?node) as ?index)
    optional {
              ?view rdf:type archimate:View;
                    archimate:contains+ ?prevNode.
              ?prevNode rdf:type ?prevNodeClass.
              filter (?prevNodeClass in (archimate:ViewNode, archimate:Container, archimate:Note, archimate:ViewReference))
              bind(str(?prevNode) as ?prevIndex)
              filter(?prevIndex < ?index)
             } 
     } group by ?view ?node
  }
  
  # Establish instance of rdfs:member for the node.
  # Take into account that the indexMember starts with 0 and hence needs an offset of +1
  
  BIND(IRI(CONCAT(STR(rdf:), "_", STR(?indexMember+1))) as ?memberNode)
 
  }
''';
    rdfs:isDefinedBy archiSVG:.

shp:ConnectionConnector
    a sh:NodeShape;
    sh:rule rule:ConnectionConnector;
    sh:target target:ConnectionConnector;
    skos:prefLabel 'connection connector shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ConnectionConnector
    a sh:SPARQLTarget;
    rdfs:comment 'Select all archisvg connections in the model.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>

select $this {

  # Select all archisvg connections that are not connected yet.
  $this rdf:type archiSVG:Connection;

  # ...that are not processed yet
  filter not exists { 
    ?parentNode ?member $this.
    filter(strstarts(str(?member), concat(str(rdf:), '_')))
  }
}
''';
    rdfs:isDefinedBy archiSVG:.

rule:ConnectionConnector
    a sh:SPARQLRule;
    rdfs:comment 'A rule that connects a connection in the XML document with its parent node.'@en;
    skos:prefLabel 'archimate connection connector rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG: <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct: <http://purl.org/dc/terms/>
prefix foaf: <http://xmlns.com/foaf/0.1/>
prefix function: <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov: <http://www.w3.org/ns/prov#>
prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>
prefix skos: <http://www.w3.org/2004/02/skos/core#>
prefix xml: <http://www.w3.org/XML/model/def/>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>
prefix xsi: <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

  ?connections ?memberConnection $this.

} where {

  # Get the parent node
  $this prov:wasDerivedFrom ?connection.
  ?parent archimate:contains ?connection.
  ?documentNode prov:wasDerivedFrom ?parent;
                rdf:_1 ?svg.
  ?svg rdf:_4 ?connections.

  # Establish position of the connection within the parent
  {select ?parent ?connection ((count(?prevIndex)) as ?indexMember)
   where{
    ?parent archimate:contains ?connection.
    bind(str(?connection) as ?index)
    optional {
              ?parent archimate:contains ?prevConnection.
              ?prevConnection rdf:type archimate:Connection.
              bind(str(?prevConnection) as ?prevIndex)
              filter(?prevIndex < ?index)
             } 
     } group by ?parent ?connection
  }
  
  # Establish instance of rdfs:member for the connection.
  # Take into account that the indexMember starts with 0 and hence needs an offset of +1
  
  BIND(IRI(CONCAT(STR(rdf:), "_", STR(?indexMember+1))) as ?memberConnection)
 
  }
''';
    rdfs:isDefinedBy archiSVG:.


shp:ConnectionLine
    a sh:NodeShape;
    sh:rule rule:ConnectionLine;
    sh:target target:ConnectionLine;
    skos:prefLabel 'archisvg connection line shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ConnectionLine
    a sh:SPARQLTarget;
    rdfs:comment 'Select the archisvg connection line that has to get enriched with attributes.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:      <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:       <http://www.w3.org/SVG/model/def/> 

select $this {

  # Select the archiSVG connection line that needs to be processed
  $this rdf:type archiSVG:ConnectionLine, svg:Polyline.
  filter not exists { 
   $this prov:wasDerivedFrom rule:ConnectionLine.
   }
}
''';
    rdfs:isDefinedBy archiSVG:.
    
rule:ConnectionLine
    a sh:SPARQLRule;
    rdfs:comment 'A rule that adds attributes to a connection line in archiSVG.'@en;
    skos:prefLabel 'connection line rule'@en;
    sh:construct '''

prefix archimate:   <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf:        <http://xmlns.com/foaf/0.1/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:        <http://www.w3.org/ns/prov#>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:        <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix skos:        <http://www.w3.org/2004/02/skos/core#>
prefix svg:         <http://www.w3.org/SVG/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>
prefix xml:         <http://www.w3.org/XML/model/def/>

construct {

  ?connection 
         rdf:_2 ?textLine;
         archiSVG:middleX ?middleCoordinatex;
         archiSVG:middleY ?middleCoordinatey.
  
  ?textLine 
         rdf:type svg:TextElement;
         svg:font-family ?fontName ;
         svg:font-size ?fontSize ;
         svg:x ?textX;
         svg:y ?textY;
         svg:text-anchor "middle";
         rdf:_1 ?text.

  ?text  
         rdf:type svg:Text;
         xml:fragment ?textFragment.

  $this 
        svg:points ?coordinates;
        svg:transform ?translate;
        svg:transform ?rotate;
        svg:fill ?fill;
        svg:stroke ?lineColor;
        svg:stroke-width ?lineSize;
        svg:stroke-dasharray ?dasharray;
        svg:marker-start ?markerStart;
        svg:marker-end   ?markerEnd;
        prov:wasDerivedFrom rule:ConnectionLine.

} where {

  # Get text
  ?connection 
        rdf:_1 $this;
        skos:prefLabel ?label.
  
  optional{
  ?connection foaf:depicts ?relationship.
  ?relationship archimate:name ?archimateName.
  }
  bind(coalesce(?archimateName, "") as ?textFragment)
  bind(iri(concat(str(?connection), '-textLine'))     as ?textLine)
  bind(iri(concat(str(?connection), '-textFragment')) as ?text)

  optional{
  ?connection  prov:wasDerivedFrom ?archimateConnection.
  ?archimateConnection archimate:font ?fontIRI.
  ?fontIRI 
           rdf:type archimate:Font;
           archimate:fontName  ?fontName;
           archimate:fontSize  ?fontSize.
  }
  # Get the first bendpoint, if any
  optional {
    ?connection archiSVG:bendPoint ?bendPointList.
    ?bendPointList rdf:_1 ?firstBendPoint.
    ?firstBendPoint 
          rdf:type archiSVG:BendPoint;
          archiSVG:fromX ?firstBendPointx;
          archiSVG:fromY ?firstBendPointy.
    bind(concat(str(?firstBendPointx),",",str(?firstBendPointy)) as ?firstBendPointCoordinate)
  }

  # Establish start coordinate
  bind(function:getStartCoordinate(?connection, coalesce(?firstBendPoint, ?connection)) as ?startCoordinate)

  # Get the last bendpoint, if any
  optional {
    {
      select ?connection (count (?bendPoints) as ?totalBendPoints)
      where {
        ?connection
          archiSVG:bendPoint ?bendPointList.
        ?bendPointList ?memberBendPoint ?bendPoints.
      } group by ?connection
    }

    ?connection archiSVG:bendPoint ?bendPointList.
    ?bendPointList ?memberBendPoint ?lastBendPoint.
    bind(xsd:integer(strafter(str(?memberBendPoint), concat(str(rdf:), '_'))) as ?bendPointIndex)
    filter(?bendPointIndex = ?totalBendPoints)
  }

  # Get the middle bendpoint, if any
  optional {
    {
      select ?connection (count (?bendPoints) as ?totalBendPoints)
      where {
        ?connection
          archiSVG:bendPoint ?bendPointList.
        ?bendPointList ?memberBendPoint ?bendPoints.
      } group by ?connection
    }

    ?connection archiSVG:bendPoint ?bendPointList.
    ?bendPointList ?memberBendPoint ?middleBendPoint.
    bind(xsd:integer(strafter(str(?memberBendPoint), concat(str(rdf:), '_'))) as ?bendPointIndex)
    filter(?bendPointIndex = xsd:integer(floor(?totalBendPoints/2)))
    ?middleBendPoint 
          rdf:type archiSVG:BendPoint;
          archiSVG:fromX ?middleBendPointx;
          archiSVG:fromY ?middleBendPointy. 
  }

  # Establish end coordinate
  bind(function:getEndCoordinate(coalesce(?lastBendPoint, ?connection), ?connection) as ?endCoordinate)

  # Establish second coordinate
  bind(coalesce(?firstBendPointCoordinate, ?endCoordinate) as ?secondCoordinate)

  # Establish middle coordinates
  bind(function:getMidXCoordinate(?startCoordinate, ?endCoordinate, 0.0) as ?middleLineCoordinatex)
  bind(function:getMidYCoordinate(?startCoordinate, ?endCoordinate, 0.0) as ?middleLineCoordinatey)
  bind(coalesce(?middleBendPointx, ?middleLineCoordinatex) as ?middleCoordinatex)
  bind(coalesce(?middleBendPointy, ?middleLineCoordinatey) as ?middleCoordinatey)  
  
  # Establish text coordinates
  bind(function:getMidXCoordinate(?startCoordinate, ?secondCoordinate, 0.0) as ?textX)
  bind(function:getMidYCoordinate(?startCoordinate, ?secondCoordinate, 6.0) as ?textY)

  # Get the possible string of bendpoint coordinates
  optional {
    {
      select ?connection (group_concat(?bendPointCoordinate; separator=" ") as ?bendPointCoordinates)
      where {
        # First order the bendpoints based on their index
        {
          select ?connection ?bendPoint
          where {
            ?connection
              archiSVG:bendPoint ?bendPointList.
            ?bendPointList ?memberBendPoint ?bendPoint.
            bind(str(strafter(str(?memberBendPoint), concat(str(rdf:), '_'))) as ?bendPointIndex)
          } order by ?connection ?bendPointIndex
        }
        # Get the coordinates for each bendpoint
        ?bendPoint
          rdf:type archiSVG:BendPoint;
          archiSVG:fromX ?x;
          archiSVG:fromY ?y.
        bind(concat(str(?x),",",str(?y)) as ?bendPointCoordinate)
      } group by ?connection
    }
  }

  bind(concat(?startCoordinate, coalesce(concat(" ", ?bendPointCoordinates), ""), " ",?endCoordinate) as ?coordinates)

  $this prov:wasDerivedFrom ?template.

  ?template
    rdf:type svg:Polyline,
             archiSVG:Template;
    svg:fill ?fill;
    svg:stroke ?lineColor;
    svg:stroke-width ?lineSize.

  optional {
    ?template svg:stroke-dasharray ?dasharray.
  }
  
  optional {
    ?template svg:marker-start ?templateMarkerStart;
  }
  
  optional {
    ?template svg:marker-end   ?templateMarkerEnd;
  }
  
  optional {
  ?connection archiSVG:accessType ?accessType.
  }
  bind(if((?accessType='Read'  || ?accessType='Read&Write') || (!bound(?accessType) && bound(?templateMarkerStart)), ?templateMarkerStart,?unboundDummy) as ?markerStart)
  bind(if((?accessType='Write' || ?accessType='Read&Write') || (!bound(?accessType) && bound(?templateMarkerEnd))  , ?templateMarkerEnd  ,?unboundDummy) as ?markerEnd) 
}
''';
    rdfs:isDefinedBy archiSVG:.

shp:ConnectionHead
    a sh:NodeShape;
    sh:rule rule:ConnectionHead;
    sh:target target:ConnectionHead;
    skos:prefLabel 'archisvg connection head shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ConnectionHead
    a sh:SPARQLTarget;
    rdfs:comment 'Select the archisvg connection head that has to get enriched with attributes.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:      <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:       <http://www.w3.org/SVG/model/def/> 

select $this {

  # Select the archiSVG connection line that needs to be processed
  $this rdf:type archiSVG:ConnectionHead, svg:Polyline.
  filter not exists { 
   $this prov:wasDerivedFrom rule:ConnectionHead.
   }
}
''';
    rdfs:isDefinedBy archiSVG:.
    
rule:ConnectionHead
    a sh:SPARQLRule;
    rdfs:comment 'A rule that adds attributes to an connection head in archiSVG.'@en;
    skos:prefLabel 'connection head rule'@en;
    sh:construct '''

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:        <http://www.w3.org/ns/prov#>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:        <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:         <http://www.w3.org/SVG/model/def/> 

construct {

  $this svg:points ?bendPoints;
        svg:transform ?translate;
        svg:transform ?rotate;
        prov:wasDerivedFrom rule:ConnectionHead.

} where {

  ?connection ?member $this.

  $this prov:wasDerivedFrom ?template.

  ?template
            rdf:type svg:Polyline, archiSVG:Template;
            svg:fill ?fill;
            svg:stroke ?lineColor;
            svg:stroke-width ?lineSize.
 bind(function:getEndCoordinate($this, $this) as ?bendPoints)

}
''';
    rdfs:isDefinedBy archiSVG:.


shp:ConnectionTailCircle
    a sh:NodeShape;
    sh:rule rule:ConnectionTailCircle;
    sh:target target:ConnectionTailCircle;
    skos:prefLabel 'archisvg connection tail circle shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ConnectionTailCircle
    a sh:SPARQLTarget;
    rdfs:comment 'Select the archisvg connection tail circle that has to get enriched with attributes.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:      <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:       <http://www.w3.org/SVG/model/def/> 

select $this {

  # Select the archiSVG connection line that needs to be processed
  $this rdf:type archiSVG:ConnectionTail, svg:Circle.
  filter not exists { 
   $this prov:wasDerivedFrom rule:ConnectionTailCircle.
   }
}
''';
    rdfs:isDefinedBy archiSVG:.
    
rule:ConnectionTailCircle
    a sh:SPARQLRule;
    rdfs:comment 'A rule that adds attributes to a connection tail circle in archiSVG.'@en;
    skos:prefLabel 'connection tail circle rule'@en;
    sh:construct '''

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:        <http://www.w3.org/ns/prov#>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:        <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:         <http://www.w3.org/SVG/model/def/> 

construct {

  $this 
        svg:cx ?cx ;
        svg:cy ?cy ;
        svg:fill ?fill;
        svg:r ?r ;
        svg:stroke ?lineColor;
        svg:stroke-width ?lineSize;
        svg:transform ?translate;
        svg:transform ?rotate;
        prov:wasDerivedFrom rule:ConnectionTailCircle.

} where {

  ?connection ?member $this.

  $this prov:wasDerivedFrom ?template.

  ?template
            rdf:type svg:Circle, archiSVG:Template;
            svg:fill ?fill;
            svg:stroke ?lineColor;
            svg:stroke-width ?lineSize;
            svg:cx ?cx ;
            svg:cy ?cy ;
            svg:fill ?fill ;
            svg:r ?r .

}
''';
    rdfs:isDefinedBy archiSVG:.

shp:ConnectionTailPolyline
    a sh:NodeShape;
    sh:rule rule:ConnectionTailPolyline;
    sh:target target:ConnectionTailPolyline;
    skos:prefLabel 'archisvg connection tail polyline shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:ConnectionTailPolyline
    a sh:SPARQLTarget;
    rdfs:comment 'Select the archisvg connection tail polyline that has to get enriched with attributes.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:      <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:       <http://www.w3.org/SVG/model/def/> 

select $this {

  # Select the archiSVG connection line that needs to be processed
  $this rdf:type archiSVG:ConnectionTail, svg:Polyline.
  filter not exists { 
   $this prov:wasDerivedFrom rule:ConnectionTailPolyline.
   }
}
''';
    rdfs:isDefinedBy archiSVG:.

rule:ConnectionTailPolyline
    a sh:SPARQLRule;
    rdfs:comment 'A rule that adds attributes to a connection tail polyline in archiSVG.'@en;
    skos:prefLabel 'connection tail polyline rule'@en;
    sh:construct '''

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:        <http://www.w3.org/ns/prov#>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rule:        <https://data.rijksfinancien.nl/archisvg/model/rule/>
prefix svg:         <http://www.w3.org/SVG/model/def/> 

construct {

  $this svg:points ?bendPoints;
        svg:transform ?translate;
        svg:transform ?rotate;
        svg:fill ?fill;
        svg:stroke ?lineColor;
        svg:stroke-width ?lineSize;
        prov:wasDerivedFrom rule:ConnectionTailPolyline.

} where {

  ?connection ?member $this.

  $this prov:wasDerivedFrom ?template.

  ?template
            rdf:type svg:Polyline, archiSVG:Template;
            svg:fill ?fill;
            svg:stroke ?lineColor;
            svg:stroke-width ?lineSize.
 bind(function:getStartCoordinate($this, $this) as ?bendPoints)

}
''';
    rdfs:isDefinedBy archiSVG:.

shp:TextCreator
    a sh:NodeShape;
    sh:rule rule:TextCreator;
    sh:target target:TextCreator;
    skos:prefLabel 'text creator shape'@en;
    rdfs:isDefinedBy archiSVG:.

target:TextCreator
    a sh:SPARQLTarget;
    rdfs:comment 'Select all text nodes in the archisvg document.'@en;
    sh:select '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>

select $this {

  # Select all text elements.. 
  
  $this rdf:type archiSVG:TextElement, svg:TextElement.
 
  # ...that have not reached the text limit yet.
  filter not exists { 
    $this archiSVG:maxLines ?maxLines;
          archiSVG:textLines ?textLines;
          ?member [].
    filter(strstarts(str(?member), concat(str(rdf:), '_')))          
    bind(xsd:integer(strafter(str(?member), concat(str(rdf:), '_'))) as ?lineIndex)
    filter((?lineIndex = ?textLines) || (?lineIndex = ?maxLines))    
  }
}
''';
    rdfs:isDefinedBy archiSVG:.


rule:TextCreator
    a sh:SPARQLRule;
    rdfs:comment 'A rule that creates an archisvg tspan node in the XML document for each line of text in the elements name.'@en;
    skos:prefLabel 'archisvg text creator rule'@en;
    sh:construct '''

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix archiSVG:  <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix dct:       <http://purl.org/dc/terms/>
prefix foaf:      <http://xmlns.com/foaf/0.1/>
prefix function:  <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix prov:      <http://www.w3.org/ns/prov#>
prefix rdf:       <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix rdfs:      <http://www.w3.org/2000/01/rdf-schema#>
prefix skos:      <http://www.w3.org/2004/02/skos/core#>
prefix svg:       <http://www.w3.org/SVG/model/def/>
prefix xml:       <http://www.w3.org/XML/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>
prefix xsi:       <http://www.w3.org/2001/XMLSchema-instance/model/def/>

construct {

    $this ?memberText ?tspan.
    ?tspan 
          rdf:type svg:Tspan;
          skos:prefLabel ?textFragment;
          svg:x ?horizontal;
          svg:y ?vertical;
          rdf:_1 ?text.

    ?text rdf:type svg:Text;
          xml:fragment ?textFragment;

} where {
  
  $this 
          skos:prefLabel ?elementName;
          svg:font-size      ?fontSize;
          svg:x              ?x ;
          svg:y              ?y ;
          archiSVG:maxChars  ?maxChars;
          archiSVG:maxLines  ?maxLines;
          archiSVG:textLines ?textLines.
          
  optional {
    {
      select (max(?lineIndex) as ?previousLineIndex) where {
        $this ?member [].
        filter(strstarts(str(?member), concat(str(rdf:), '_')))
        bind(xsd:integer(strafter(str(?member), concat(str(rdf:), '_'))) as ?lineIndex)
      }
    }
  }

  # Establish fragment metadata
  bind(coalesce(?previousLineIndex+1, 1) as ?lineIndex)
  bind(xsd:integer(((?lineIndex-1)*?maxChars)+1) as ?sliceStart)
  bind(if(?lineIndex <= ?textLines && ?lineIndex <= ?maxLines, substr(?elementName,?sliceStart, ?maxChars), ?unboundDummy) as ?textFragment)
  bind(iri(concat(str(rdf:),"_", str(?lineIndex))) as ?memberText)
  bind((xsd:decimal(?y) + 10 + (1.2*xsd:decimal(?fontSize)*(?lineIndex-1))) as ?vertical)
  bind(xsd:decimal(?x) as ?horizontal)

  # Create IRI's
  bind(iri(concat(str($this),"-SVG-Span-", str(?lineIndex))) as ?tspan)
  bind(iri(concat(str($this),"-SVG-Text-", str(?lineIndex))) as ?text)

}
''';
    rdfs:isDefinedBy archiSVG:.

function:getStartCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a string containing the start coordinates for a connection line in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:string ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg:         <http://www.w3.org/SVG/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result where {

      $from
        archiSVG:fromX ?fromX_string ;
        archiSVG:fromY ?fromY_string .
        
      optional{
      $from
        archiSVG:fromW ?fromW_string ;
        archiSVG:fromH ?fromH_string .
      }
      
      $to
        archiSVG:toX ?toX_string ;
        archiSVG:toY ?toY_string .
        
      optional{
      $to
        archiSVG:toW ?toW_string ;
        archiSVG:toH ?toH_string .
      }
    
    bind(xsd:decimal(?fromX_string)                  as ?fromX)
    bind(xsd:decimal(?fromY_string)                  as ?fromY)
    bind(xsd:decimal(coalesce(?fromW_string, '0.0')) as ?fromW)
    bind(xsd:decimal(coalesce(?fromH_string, '0.0')) as ?fromH)
    bind(xsd:decimal(?toX_string)                    as ?toX)
    bind(xsd:decimal(?toY_string)                    as ?toY)
    bind(xsd:decimal(coalesce(?toW_string, '0.0'))   as ?toW)
    bind(xsd:decimal(coalesce(?toH_string, '0.0'))   as ?toH)

    
    # 1. Diagonal line
    
    # Quadrant 1: diagonal line when [a] left of [b] and [a] above [b]       
    bind(if(((?fromX + ?fromW < ?toX) && (?fromY + ?fromH < ?toY)), str(?fromX + ?fromW),     ?unboundDummy) as ?startDiagonalX1)
    bind(if(((?fromX + ?fromW < ?toX) && (?fromY + ?fromH < ?toY)), str(?fromY + ?fromH),     ?unboundDummy) as ?startDiagonalY1)

    # Quadrant 2: diagonal line when [a] right of [b] and [a] above [b]
    bind(if(((?toX + ?toW < ?fromX)   && (?fromY + ?fromH < ?toY)), str(?fromX),              ?unboundDummy) as ?startDiagonalX2)
    bind(if(((?toX + ?toW < ?fromX)   && (?fromY + ?fromH < ?toY)), str(?fromY + ?fromH),     ?unboundDummy) as ?startDiagonalY2)

    # Quadrant 3: diagonal line when [a] right of [b] and [a] below [b]
    bind(if(((?toX + ?toW < ?fromX))  && (?toY + ?toH < ?fromY), str(?fromX),                 ?unboundDummy) as ?startDiagonalX3)
    bind(if(((?toX + ?toW < ?fromX))  && (?toY + ?toH < ?fromY), str(?fromY),                 ?unboundDummy) as ?startDiagonalY3)

    # Quadrant 4: diagonal line when [a] left of [b] and [a] below [b] 
    bind(if(((?fromX + ?fromW < ?toX) && (?toY + ?toH < ?fromY)), str(?fromX + ?fromW),       ?unboundDummy) as ?startDiagonalX4)
    bind(if(((?fromX + ?fromW < ?toX) && (?toY + ?toH < ?fromY)), str(?fromY),                ?unboundDummy) as ?startDiagonalY4)


    # 2. Horizontal line
    # horizontal line when [a] and [b] are overlapping vertically   
    
    bind(if(function:isVerticalOverlap($from, $to),   function:getStartHorizontalCoordinate($from, $to)                                    , ?unboundDummy) as ?startHorizontalLineX)
    bind(if(function:isVerticalOverlap($from, $to),   function:getMaxVerticalCoordinate($from, $to) + function:getDeltaVertical($from, $to), ?unboundDummy) as ?startHorizontalLineY)

    # 3. Vertical line
    # vertical line when [a] and [b] are overlapping horizontally   
    
    bind(if(function:isHorizontalOverlap($from, $to), function:getMaxHorizontalCoordinate($from, $to) + function:getDeltaHorizontal($from, $to), ?unboundDummy) as ?startVerticalLineX)
    bind(if(function:isHorizontalOverlap($from, $to), function:getStartVerticalCoordinate($from, $to)                                          , ?unboundDummy) as ?startVerticalLineY)

    # 4. Concatenate result
    
    bind(concat(str(coalesce(?startDiagonalX1,?startDiagonalX2,?startDiagonalX3,?startDiagonalX4,?startHorizontalLineX, ?startVerticalLineX,"")), ',', str(coalesce(?startDiagonalY1,?startDiagonalY2,?startDiagonalY3,?startDiagonalY4,?startHorizontalLineY, ?startVerticalLineY,""))) as ?result)
}
""" .

function:getEndCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a string containing the end coordinate for a connection line in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:string ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
prefix svg:         <http://www.w3.org/SVG/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result where {

      $from
        archiSVG:fromX ?fromX_string ;
        archiSVG:fromY ?fromY_string .
        
      optional{
      $from
        archiSVG:fromW ?fromW_string ;
        archiSVG:fromH ?fromH_string .
      }
      
      $to
        archiSVG:toX ?toX_string ;
        archiSVG:toY ?toY_string .

      optional{
      $to
        archiSVG:toW ?toW_string ;
        archiSVG:toH ?toH_string .
      }
    
    bind(xsd:decimal(?fromX_string)                  as ?fromX)
    bind(xsd:decimal(?fromY_string)                  as ?fromY)
    bind(xsd:decimal(coalesce(?fromW_string, '0.0')) as ?fromW)
    bind(xsd:decimal(coalesce(?fromH_string, '0.0')) as ?fromH)
    bind(xsd:decimal(?toX_string)                    as ?toX)
    bind(xsd:decimal(?toY_string)                    as ?toY)
    bind(xsd:decimal(coalesce(?toW_string, '0.0'))   as ?toW)
    bind(xsd:decimal(coalesce(?toH_string, '0.0'))   as ?toH)
    
    
    # 1. Diagonal line
    
    # Quadrant 1: diagonal line when [a] left of [b] and [a] above [b]       
    bind(if(((?fromX + ?fromW < ?toX) && (?fromY + ?fromH < ?toY)), str(?toX),                ?unboundDummy) as ?endDiagonalX1)
    bind(if(((?fromX + ?fromW < ?toX) && (?fromY + ?fromH < ?toY)), str(?toY),                ?unboundDummy) as ?endDiagonalY1)

    # Quadrant 2: diagonal line when [a] right of [b] and [a] above [b]
    bind(if(((?toX + ?toW < ?fromX)   && (?fromY + ?fromH < ?toY)), str(?toX+?toW),           ?unboundDummy) as ?endDiagonalX2)
    bind(if(((?toX + ?toW < ?fromX)   && (?fromY + ?fromH < ?toY)), str(?toY),                ?unboundDummy) as ?endDiagonalY2)

    # Quadrant 3: diagonal line when [a] right of [b] and [a] below [b]
    bind(if(((?toX + ?toW < ?fromX)) && (?toY + ?toH < ?fromY), str(?toX+?toW),               ?unboundDummy) as ?endDiagonalX3)
    bind(if(((?toX + ?toW < ?fromX)) && (?toY + ?toH < ?fromY), str(?toY+?toH),               ?unboundDummy) as ?endDiagonalY3)

    # Quadrant 4: diagonal line when [a] left of [b] and [a] below [b] 
    bind(if(((?fromX + ?fromW < ?toX) && (?toY + ?toH < ?fromY)), str(?toX),                  ?unboundDummy) as ?endDiagonalX4)
    bind(if(((?fromX + ?fromW < ?toX) && (?toY + ?toH < ?fromY)), str(?toY+?toH),             ?unboundDummy) as ?endDiagonalY4)


    # 2. Horizontal line
    # horizontal line when [a] and [b] are overlapping vertically   
    
    bind(if(function:isVerticalOverlap($from, $to),   function:getEndHorizontalCoordinate($from, $to)                                        ,   ?unboundDummy) as ?endHorizontalLineX)
    bind(if(function:isVerticalOverlap($from, $to),   function:getMaxVerticalCoordinate($from, $to)   + function:getDeltaVertical($from, $to),   ?unboundDummy) as ?endHorizontalLineY)

    # 3. Vertical line
    # vertical line when [a] and [b] are overlapping horizontally   
    
    bind(if(function:isHorizontalOverlap($from, $to), function:getMaxHorizontalCoordinate($from, $to) + function:getDeltaHorizontal($from, $to), ?unboundDummy) as ?endVerticalLineX)
    bind(if(function:isHorizontalOverlap($from, $to), function:getEndVerticalCoordinate($from, $to)                                            , ?unboundDummy) as ?endVerticalLineY)

    # 4. Concatenate result
    
    bind(concat(str(coalesce(?endDiagonalX1,?endDiagonalX2,?endDiagonalX3,?endDiagonalX4,?endHorizontalLineX, ?endVerticalLineX,"")), ',', str(coalesce(?endDiagonalY1,?endDiagonalY2,?endDiagonalY3,?endDiagonalY4,?endHorizontalLineY, ?endVerticalLineY,""))) as ?result)
}
""" .



function:getMinHorizontalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the smallest horizontal coordinate of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select (MIN(?Xend) as ?result)

where {
          {select $from $to (coalesce(?Xend1, ?Xend2) as ?Xend) where {
              {
              $from
                archiSVG:fromX ?fromX_string .
                
               optional{
               $from
                archiSVG:fromW ?fromW_string .
               }
               bind((xsd:decimal(?fromX_string) + xsd:decimal(coalesce(?fromW_string,0.0))) as ?Xend1)  
              }

          UNION

             {
              $to
                archiSVG:toX ?toX_string .
                
              optional{
              $to
                archiSVG:toW ?toW_string .
              }       
              bind((xsd:decimal(?toX_string) + xsd:decimal(coalesce(?toW_string,0.0))) as ?Xend2)  
             }
            }
          }
        }
""" .

function:getStartHorizontalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the horizontal start coordinate of a horizontal line for the visual vertical overlap of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      $from
        archiSVG:fromX ?fromX_string .
        
      optional{
      $from
        archiSVG:fromW ?fromW_string .
      }
      bind(xsd:decimal(?fromX_string) as ?fromX)
      bind(coalesce(xsd:decimal(?fromW_string), 0.0) as ?fromW)

      $to
        archiSVG:toX ?toX_string .
        
      optional{
      $to
        archiSVG:toW ?toW_string .
      }
      bind(xsd:decimal(?toX_string) as ?toX)
      bind(coalesce(xsd:decimal(?toW_string), 0.0) as ?toW)

      bind(if(?toX + ?toW < ?fromX, ?fromX, if(?toX > ?fromX + ?fromW, ?fromX + ?fromW, ?unboundDummy)) as ?result)
}
""" .

function:getStartVerticalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the vertical start coordinate of a vertical line for the visual horizontal overlap of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      $from
        archiSVG:fromY ?fromY_string .
        
      optional{
      $from
        archiSVG:fromH ?fromH_string .
      }
      bind(xsd:decimal(?fromY_string) as ?fromY)
      bind(coalesce(xsd:decimal(?fromH_string), 0.0) as ?fromH)

      $to
        archiSVG:toY ?toY_string .
        
      optional{
      $to
        archiSVG:toH ?toH_string .
      }
      bind(xsd:decimal(?toY_string) as ?toY)
      bind(coalesce(xsd:decimal(?toH_string), 0.0) as ?toH)

      bind(if(?toY + ?toH < ?fromY, ?fromY, if(?toY > ?fromY + ?fromH, ?fromY + ?fromH, ?unboundDummy)) as ?result)
}
""" .

function:getEndHorizontalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the horizontal end coordinate of a horizontal line for the visual vertical overlap of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      $from
        archiSVG:fromX ?fromX_string .
        
      optional{
      $from
        archiSVG:fromW ?fromW_string .
      }
      bind(xsd:decimal(?fromX_string) as ?fromX)
      bind(coalesce(xsd:decimal(?fromW_string), 0.0) as ?fromW)

      $to
        archiSVG:toX ?toX_string .
        
      optional{
      $to
        archiSVG:toW ?toW_string .
      }
      bind(xsd:decimal(?toX_string) as ?toX)
      bind(coalesce(xsd:decimal(?toW_string), 0.0) as ?toW)

      bind(if(?toX > ?fromX + ?fromW, ?toX, if(?toX + ?toW < ?fromX, ?toX + ?toW, ?unboundDummy)) as ?result)
}
""" .

function:getEndVerticalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the vertical end coordinate of a vertical line for the visual horizontal overlap of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      $from
        archiSVG:fromY ?fromY_string .
        
      optional{
      $from
        archiSVG:fromH ?fromH_string .
      }
      bind(xsd:decimal(?fromY_string) as ?fromY)
      bind(coalesce(xsd:decimal(?fromH_string), 0.0) as ?fromH)

      $to
        archiSVG:toY ?toY_string .
        
      optional{
      $to
        archiSVG:toH ?toH_string .
      }
      bind(xsd:decimal(?toY_string) as ?toY)
      bind(coalesce(xsd:decimal(?toH_string), 0.0) as ?toH)

      bind(if(?toY > ?fromY + ?fromH, ?toY, if(?toY + ?toH < ?fromY, ?toY + ?toH, ?unboundDummy)) as ?result)
}
""" .

function:isHorizontalOverlap
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a boolean indicating whether there is overlap for two concepts in the X-axis in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:boolean ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      bind(function:getMinHorizontalCoordinate($from, $to) as ?minEndCoordinate)
      bind(function:getMaxHorizontalCoordinate($from, $to) as ?maxStartCoordinate)
      bind((?minEndCoordinate-?maxStartCoordinate) as ?differenceMinMax)
      bind(if(?differenceMinMax >= 0.0, true, false) as ?result)
      
}
""" .


function:isVerticalOverlap
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a boolean indicating whether there is overlap for two concepts in the Y-axis in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:boolean ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      bind(function:getMinVerticalCoordinate($from, $to) as ?minEndCoordinate)
      bind(function:getMaxVerticalCoordinate($from, $to) as ?maxStartCoordinate)
      bind((?minEndCoordinate-?maxStartCoordinate) as ?differenceMinMax)
      bind(if(?differenceMinMax >= 0.0, true, false) as ?result)
      
}
""" .

function:getDeltaHorizontal
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the horizontal distance that is half the horizontal visual overlap of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select (?halfOverlapDistance as ?result)

where {
  
      bind(function:getMinHorizontalCoordinate($from, $to) as ?minEndCoordinate)
      bind(function:getMaxHorizontalCoordinate($from, $to) as ?maxStartCoordinate)
      bind((?minEndCoordinate-?maxStartCoordinate) as ?differenceMinMax)
      bind(if(?differenceMinMax > 0.0, ?differenceMinMax, 0.0) as ?overlapDistance)
      bind((?overlapDistance/2.0) as ?halfOverlapDistance)
      
}
""" .

function:getMaxHorizontalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the biggest horizontal coordinate of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select (MAX(?Xstart) as ?result)

where {
      {select $from $to (coalesce(?Xstart1, ?Xstart2) as ?Xstart) where {
      {$from
        archiSVG:fromX ?fromX_string .
        
      optional{
      $from
        archiSVG:fromW ?fromW_string .
      }
      bind(xsd:decimal(?fromX_string) as ?Xstart1)
        }

      UNION

      {
      $to
        archiSVG:toX ?toX_string .
        
      optional{
      $to
        archiSVG:toW ?toW_string .
      }
      bind(xsd:decimal(?toX_string) as ?Xstart2)        
}
}
} 
}
""" .

function:getMinVerticalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the smallest vertical coordinate of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select (MIN(?Yend) as ?result)

where {
      {select $from $to (coalesce(?Yend1, ?Yend2) as ?Yend) where {
      {$from
        archiSVG:fromY ?fromY_string .
        
      optional{
      $from
        archiSVG:fromH ?fromH_string .
      }
      bind((xsd:decimal(?fromY_string) + xsd:decimal(coalesce(?fromH_string,0.0))) as ?Yend1)  
        }

      UNION

      {
      $to
        archiSVG:toY ?toY_string .
        
      optional{
      $to
        archiSVG:toH ?toH_string .
      }       
      bind((xsd:decimal(?toY_string) + xsd:decimal(coalesce(?toH_string,0.0))) as ?Yend2)  
}
}
}
}
""" .

function:getMaxVerticalCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the biggest vertical coordinate of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select (MAX(?Ystart) as ?result)

where {
      {select $from $to (coalesce(?Ystart1, ?Ystart2) as ?Ystart) where {
      {$from
        archiSVG:fromY ?fromY_string .
        
      optional{
      $from
        archiSVG:fromH ?fromH_string .
      }
      bind(xsd:decimal(?fromY_string) as ?Ystart1)
        }

      UNION

      {
      $to
        archiSVG:toY ?toY_string .
        
      optional{
      $to
        archiSVG:toH ?toH_string .
      }
      bind(xsd:decimal(?toY_string) as ?Ystart2)
} 
}
}
}
""" .

function:getDeltaVertical
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a decimal containing the vertical distance that is half the vertical visual overlap of two concepts in an archimate view." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:anyURI ;
        sh:description "The element from which the connection starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:anyURI ;
        sh:description "The element where the connection ends." ;
        sh:order 2;
    ] ;    
    sh:returnType xsd:decimal ;
    sh:select """

prefix archiSVG:    <https://data.rijksfinancien.nl/archisvg/model/def/>
prefix function:    <https://data.rijksfinancien.nl/archisvg/model/function/>
prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select (?halfOverlapDistance as ?result)

where {
  
      bind(function:getMinVerticalCoordinate($from, $to) as ?minEndCoordinate)
      bind(function:getMaxVerticalCoordinate($from, $to) as ?maxStartCoordinate)
      bind((?minEndCoordinate-?maxStartCoordinate) as ?differenceMinMax)
      bind(if(?differenceMinMax > 0.0, ?differenceMinMax, 0.0) as ?overlapDistance)
      bind((?overlapDistance/2.0) as ?halfOverlapDistance)
      
}
""" .


function:escapeXML
    a sh:SPARQLFunction ;
    rdfs:comment "Escapes XML characters in the input string." ;
    sh:parameter [
        sh:path function:input ;
        sh:datatype xsd:string ;
        sh:description "The input string to escape XML characters from." ;
    ] ;
    sh:returnType xsd:string ;
    sh:select """
       SELECT ?result WHERE {
       BIND(replace(
                    replace(
                        replace(
                            replace(
                                replace(
                                    $input,
                                    '&', '&amp;'),
                                '<', '&lt;'),
                            '>', '&gt;'),
                        '\"', '&quot;'),
                    "\'", '&apos;')
                AS ?result).
        }
        """ .
        
function:getViewBox
    a sh:SPARQLFunction ;
    rdfs:comment "Returns the viewbox dimensions for a view." ;
    sh:parameter [
        sh:path function:view ;
        sh:datatype xsd:anyURI ;
        sh:description "A view." ;
    ] ;
    sh:returnType xsd:string ;
    sh:select """

prefix archimate: <https://data.rijksfinancien.nl/archimate/model/def/>
prefix xsd:       <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
{select $view (min(?xCoordinate) as ?minX)
where {
  $view archimate:contains ?object.
  ?object archimate:horizontal ?x.
  bind(xsd:decimal(?x) as ?xCoordinate)
  } group by $view
} 

{select $view (max(?xCoordinate) as ?maxX)
where {
  $view archimate:contains ?object.
  ?object archimate:horizontal ?x;
          archimate:width ?width.
  bind(xsd:decimal(?x)+ xsd:decimal(?width) as ?xCoordinate)
  } group by $view
}

{select $view (min(?yCoordinate) as ?minY)
where {
  $view archimate:contains ?object.
  ?object archimate:vertical ?y.
  bind(xsd:decimal(?y) as ?yCoordinate)
  } group by $view
}

{select $view (max(?yCoordinate) as ?maxY)
where {
  $view archimate:contains ?object.
  ?object archimate:vertical ?y;
          archimate:height ?height.
  bind(xsd:decimal(?y)+ xsd:decimal(?height) as ?yCoordinate)
  } group by $view
}

bind(concat(str(?minX), " ",str(?minY), " ",str(?maxX+1), " ",str(?maxY+1)) as ?result)
      
}
""" .

function:getMidXCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a string containing the X coordinate for the middle point of a line between two input coordinates." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:string ;
        sh:description "The coordinate from which the line starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:string ;
        sh:description "The coordinate where the line ends." ;
        sh:order 2;        
    ] ;    
    sh:parameter [
        sh:path function:padding ;
        sh:datatype xsd:decimal ;
        sh:description "A padding." ;
        sh:order 3;        
    ] ;     
    sh:returnType xsd:string ;
    sh:select """

prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      bind(xsd:decimal(strbefore($from, ","))   as ?start)
      bind(xsd:decimal(strbefore($to  , ","))   as ?end)
      bind(str(((?start + ?end)/2) - $padding)     as ?result)
      
}
""" .

function:getMidYCoordinate
    a sh:SPARQLFunction ;
    rdfs:comment "Returns a string containing the Y coordinate for the middle point of a line between two input coordinates." ;
    sh:parameter [
        sh:path function:from ;
        sh:datatype xsd:string ;
        sh:description "The coordinate from which the line starts." ;
        sh:order 1;
    ] ;
    sh:parameter [
        sh:path function:to ;
        sh:datatype xsd:string ;
        sh:description "The coordinate where the line ends." ;
        sh:order 2;        
    ] ;    
    sh:parameter [
        sh:path function:padding ;
        sh:datatype xsd:decimal ;
        sh:description "A padding." ;
        sh:order 3;        
    ] ;        
    sh:returnType xsd:string ;
    sh:select """

prefix xsd:         <http://www.w3.org/2001/XMLSchema#>

select ?result

where {
  
      bind(xsd:decimal(strafter($from, ","))       as ?start)
      bind(xsd:decimal(strafter($to  , ","))       as ?end)
      bind(str(((?start + ?end)/2) - $padding)     as ?result)

}
""" .

}